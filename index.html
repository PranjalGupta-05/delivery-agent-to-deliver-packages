<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSA2001 - Autonomous Delivery Agent Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif;
            background: #000000;
            background: linear-gradient(90deg, rgba(255, 255, 255, 1) 0%, rgba(7, 147, 168, 1) 100%);
        }
        /* A simple animation for log entries */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .log-entry {
            animation: fadeIn 0.3s ease-out;
        }
        /* Ensure the grid cells don't have weird spacing issues */
        .grid-cell {
            width: 100%;
            height: 100%;
        }
        /* Custom scrollbar for the log */
        #log-container::-webkit-scrollbar {
            width: 8px;
        }
        #log-container::-webkit-scrollbar-track {
            background: #e2e8f0; /* slate-200 */
        }
        #log-container::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 4px;
        }
        #log-container::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="text-slate-800">

    <div class="container mx-auto p-4 md:p-6 lg:p-8">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-sky-600">Autonomous Delivery Agent Simulator</h1>
            <p class="text-slate-600 mt-1">Project 1 - Fundamentals of AI and ML</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Main Content: Grid -->
            <main class="flex-grow flex flex-col items-center justify-center bg-white/30 p-2 rounded-lg shadow-2xl shadow-sky-500/20">
                 <div id="grid-container" class="w-full h-full max-w-5xl aspect-video">
                    <!-- The grid will be generated by JavaScript here -->
                </div>
            </main>

            <!-- Side Panel: Controls, Stats, Log -->
            <aside class="w-full lg:w-96 bg-slate-100/50 backdrop-blur-sm p-6 rounded-lg shadow-lg flex flex-col gap-6">
                <!-- Controls -->
                <div class="flex flex-col gap-4">
                     <h2 class="text-xl font-semibold border-b-2 border-sky-500 pb-2">Controls</h2>
                     <div>
                        <label for="map-select" class="block text-sm font-medium text-slate-700 mb-1">1. Select Map</label>
                        <select id="map-select" class="w-full bg-white border border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-2 focus:ring-sky-500 transition">
                            <!-- Options will be added by JavaScript -->
                        </select>
                     </div>
                     <div>
                        <label for="algo-select" class="block text-sm font-medium text-slate-700 mb-1">2. Select Algorithm</label>
                        <select id="algo-select" class="w-full bg-white border border-slate-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-2 focus:ring-sky-500 transition">
                            <!-- Options will be added by JavaScript -->
                        </select>
                    </div>
                    <div class="flex gap-4">
                         <button id="start-btn" class="flex-1 bg-sky-600 hover:bg-sky-500 disabled:bg-slate-400 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-md transition-all duration-300 shadow-lg hover:shadow-sky-500/50">
                            Start Delivery
                        </button>
                        <button id="reset-btn" class="flex-1 bg-slate-300 hover:bg-slate-400 disabled:bg-slate-200 text-slate-800 font-bold py-2 px-4 rounded-md transition-colors">
                            Reset
                        </button>
                    </div>
                </div>

                <!-- Stats -->
                 <div class="flex flex-col gap-2">
                     <h2 class="text-xl font-semibold border-b-2 border-green-500 pb-2">Results</h2>
                     <div id="stats-container" class="bg-slate-200/50 p-4 rounded-md text-sm">
                         <p class="text-slate-600">Run a simulation to see results.</p>
                     </div>
                 </div>

                <!-- Log -->
                <div class="flex flex-col gap-2 flex-grow min-h-0">
                    <h2 class="text-xl font-semibold border-b-2 border-purple-500 pb-2">Event Log</h2>
                    <div id="log-container" class="bg-slate-200/70 p-3 rounded-md text-xs font-mono flex-grow overflow-y-auto h-32">
                        <!-- Log messages will be added here -->
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <script>
        // --- CONFIGURATION AND CONSTANTS ---
        const TILE_TYPE = {
            EMPTY: 0,
            WALL: 1,
            START: 2,
            END: 3,
            ROAD: 1,  // Terrain Costs
            GRASS: 3,
            WATER: 5,
        };

        const TILE_STYLES = {
            BASE: 'transition-colors duration-500',
            [TILE_TYPE.START]: 'bg-green-500',
            [TILE_TYPE.END]: 'bg-red-500',
            [TILE_TYPE.WALL]: 'bg-gray-500',
            PATH: 'bg-blue-500',
            VISITED: 'bg-sky-700/80',
            AGENT: 'bg-yellow-400',
            DYNAMIC_OBSTACLE: 'bg-purple-600',
        };

        const TERRAIN_STYLES = {
            [TILE_TYPE.ROAD]: 'bg-slate-400',
            [TILE_TYPE.GRASS]: 'bg-green-800/60',
            [TILE_TYPE.WATER]: 'bg-blue-800/60',
        };

        const ALGORITHMS = {
            BFS: 'Breadth-First Search (Uninformed)',
            UCS: 'Uniform-Cost Search (Uninformed)',
            A_STAR: 'A* Search (Informed)',
            A_STAR_REPLAN: 'A* with Replanning',
        };

        const ANIMATION_SPEEDS = {
            VISITED: 15,
            AGENT: 100,
        };
        
        // --- MAP DEFINITIONS ---
        // A function to create and configure maps to avoid global scope pollution
        function defineMaps() {
            const maps = {
                small: {
                    name: "Small Office",
                    grid: [
                        [2, 0, 0, 0, 1, 0, 0, 0, 0, 0],
                        [0, 1, 1, 0, 1, 0, 1, 1, 1, 0],
                        [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
                        [0, 1, 0, 1, 1, 1, 1, 0, 1, 0],
                        [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
                        [1, 1, 1, 1, 1, 0, 1, 1, 1, 0],
                        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
                        [0, 1, 1, 0, 1, 1, 1, 1, 1, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0, 1, 3],
                    ],
                    terrain: null,
                },
                medium: {
                    name: "Medium Warehouse (with Terrain)",
                    grid: Array(15).fill(0).map(() => Array(25).fill(0)),
                    terrain: Array(15).fill(0).map(() => Array(25).fill(TILE_TYPE.ROAD)),
                },
                large: {
                    name: "Large City Block",
                    grid: Array(25).fill(0).map(() => Array(40).fill(0)),
                    terrain: Array(25).fill(0).map(() => Array(40).fill(TILE_TYPE.ROAD)),
                },
                dynamic: {
                    name: "Dynamic Highway",
                    grid: Array(15).fill(0).map(() => Array(25).fill(0)),
                    terrain: Array(15).fill(0).map(() => Array(25).fill(TILE_TYPE.ROAD)),
                    dynamicObstacles: [
                        { id: 1, path: Array.from({length: 20}, (_, i) => ({ y: 3, x: 2 + i })) },
                        { id: 2, path: Array.from({length: 20}, (_, i) => ({ y: 11, x: 22 - i })) },
                    ],
                },
            };

            // Procedurally generate medium map
            const medGrid = maps.medium.grid;
            const medTerrain = maps.medium.terrain;
            medGrid[2][2] = TILE_TYPE.START;
            medGrid[12][22] = TILE_TYPE.END;
            for(let i=0; i<15; i++) {
                for(let j=0; j<25; j++) {
                    if (medGrid[i][j] === 0 && Math.random() > 0.8) medGrid[i][j] = TILE_TYPE.WALL;
                    if(j > 5 && j < 19) medTerrain[i][j] = TILE_TYPE.GRASS;
                    if((i > 4 && i < 10) && (j > 8 && j < 16)) medTerrain[i][j] = TILE_TYPE.WATER;
                }
            }

            // Procedurally generate large map
            const largeGrid = maps.large.grid;
            for(let i = 0; i < 25; i++) {
                if (i % 4 === 0 || i % 4 === 1) continue;
                for(let j = 0; j < 40; j++) {
                    if (j % 5 !== 0 && Math.random() > 0.1) largeGrid[i][j] = TILE_TYPE.WALL;
                }
            }
            largeGrid[2][2] = TILE_TYPE.START;
            largeGrid[22][37] = TILE_TYPE.END;
            
            // Setup dynamic map
            const dynGrid = maps.dynamic.grid;
            dynGrid[7][2] = TILE_TYPE.START;
            dynGrid[7][22] = TILE_TYPE.END;
            for(let x=0; x<25; x++) {
                if (x % 6 !== 0 ) {
                    dynGrid[2][x] = TILE_TYPE.WALL;
                    dynGrid[4][x] = TILE_TYPE.WALL;
                    dynGrid[10][x] = TILE_TYPE.WALL;
                    dynGrid[12][x] = TILE_TYPE.WALL;
                }
            }
            
            return maps;
        }
        
        const MAPS = defineMaps();

        // --- HELPER CLASSES & FUNCTIONS ---

        /**
         * A simple Priority Queue implementation for pathfinding algorithms.
         */
        class PriorityQueue {
            constructor() { this.elements = []; }
            enqueue(element, priority) {
                this.elements.push({ element, priority });
                this.elements.sort((a, b) => a.priority - b.priority);
            }
            dequeue() { return this.elements.shift().element; }
            isEmpty() { return this.elements.length === 0; }
        }

        /**
         * Manhattan distance heuristic for A*. It's admissible because it never overestimates the cost.
         * @param {{y: number, x: number}} a - The first point.
         * @param {{y: number, x: number}} b - The second point.
         * @returns {number} The Manhattan distance.
         */
        function manhattanDistance(a, b) {
            return Math.abs(a.y - b.y) + Math.abs(a.x - b.x);
        }

        /**
         * Finds the start and end coordinates from a grid.
         * @param {number[][]} grid - The map grid.
         * @returns {{start: {y, x}|null, end: {y, x}|null}}
         */
        function findStartEnd(grid) {
            let start = null, end = null;
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    if (grid[y][x] === TILE_TYPE.START) start = { y, x };
                    if (grid[y][x] === TILE_TYPE.END) end = { y, x };
                }
            }
            return { start, end };
        }

        // --- CORE PATHFINDING ALGORITHM ---

        /**
         * Solves the grid using the specified algorithm.
         * @param {string} algorithm - The algorithm to use (from ALGORITHMS).
         * @param {number[][]} grid - The current state of the map.
         * @param {{y, x}} start - The starting node.
         * @param {{y, x}} end - The goal node.
         * @param {number[][]|null} terrain - The terrain cost map.
         * @returns {{path: {y,x}[], visitedOrder: {y,x}[], totalCost: number, time: string}}
         */
        function solve(algorithm, grid, start, end, terrain) {
            if (!start || !end) {
                console.error("Solve function called with null start or end point.");
                return { path: [], visitedOrder: [], totalCost: 0, time: '0.00' };
            }
            const startTime = performance.now();
            const rows = grid.length;
            const cols = grid[0].length;
            
            const getCost = (y, x) => (terrain ? terrain[y][x] : 1);
            
            let queue;
            if (algorithm === ALGORITHMS.BFS) {
                queue = [{ y: start.y, x: start.x }]; // Simple FIFO Queue
            } else {
                queue = new PriorityQueue();
                queue.enqueue({ y: start.y, x: start.x }, 0);
            }
            
            const cameFrom = { [`${start.y}-${start.x}`]: null };
            const costSoFar = { [`${start.y}-${start.x}`]: 0 };
            const visitedOrder = [];

            while ((algorithm === ALGORITHMS.BFS) ? queue.length > 0 : !queue.isEmpty()) {
                const current = (algorithm === ALGORITHMS.BFS) ? queue.shift() : queue.dequeue();
                
                visitedOrder.push(current);

                if (current.y === end.y && current.x === end.x) break; // Goal reached

                const neighbors = [
                    { y: current.y - 1, x: current.x }, { y: current.y + 1, x: current.x },
                    { y: current.y, x: current.x - 1 }, { y: current.y, x: current.x + 1 },
                ];

                for (const next of neighbors) {
                    if (next.y >= 0 && next.y < rows && next.x >= 0 && next.x < cols && grid[next.y][next.x] !== TILE_TYPE.WALL) {
                        const newCost = costSoFar[`${current.y}-${current.x}`] + getCost(next.y, next.x);
                        const nextKey = `${next.y}-${next.x}`;
                        
                        if (cameFrom[nextKey] === undefined || newCost < costSoFar[nextKey]) {
                            costSoFar[nextKey] = newCost;
                            let priority = (algorithm === ALGORITHMS.UCS || algorithm === ALGORITHMS.A_STAR || algorithm === ALGORITHMS.A_STAR_REPLAN) ? newCost : 0;
                            if (algorithm === ALGORITHMS.A_STAR || algorithm === ALGORITHMS.A_STAR_REPLAN) {
                                priority += manhattanDistance(next, end);
                            }
                            
                            if (algorithm === ALGORITHMS.BFS) queue.push(next);
                            else queue.enqueue(next, priority);
                            
                            cameFrom[nextKey] = current;
                        }
                    }
                }
            }
            
            // Reconstruct path and calculate total cost from goal to start
            let path = [];
            let current = end;
            let totalCost = 0;
            if(cameFrom[`${end.y}-${end.x}`] !== undefined){
                while (current) {
                    path.unshift(current);
                    const prev = cameFrom[`${current.y}-${current.x}`];
                    if (prev) { // Add cost of moving to 'current' node
                         totalCost += getCost(current.y, current.x);
                    }
                    current = prev;
                }
            }


            const endTime = performance.now();
            
            // Ensure path starts at the start node if a path was found
            const pathFound = path.length > 1 && path[0].y === start.y && path[0].x === start.x;

            return { 
                path: pathFound ? path : [], 
                visitedOrder, 
                totalCost, 
                time: (endTime - startTime).toFixed(2) 
            };
        }

        // --- DOM & UI LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            const gridContainer = document.getElementById('grid-container');
            const mapSelect = document.getElementById('map-select');
            const algoSelect = document.getElementById('algo-select');
            const startBtn = document.getElementById('start-btn');
            const resetBtn = document.getElementById('reset-btn');
            const statsContainer = document.getElementById('stats-container');
            const logContainer = document.getElementById('log-container');
            
            let state = {
                grid: null,
                terrain: null,
                dynamicObstacles: [],
                isRunning: false,
                currentAnimation: null, // To store interval IDs for clearing
            };

            function addLog(message) {
                const p = document.createElement('p');
                p.textContent = `» ${message}`;
                p.className = 'log-entry';
                logContainer.appendChild(p);
                logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll
            }

            function updateStats({ cost, nodes, time, replans }) {
                let html = `<p><strong class="text-green-400">Path Cost:</strong> ${cost}</p>
                            <p><strong class="text-green-400">Nodes Expanded:</strong> ${nodes}</p>
                            <p><strong class="text-green-400">Time Taken:</strong> ${time} ms</p>`;
                if (replans) {
                    html += `<p><strong class="text-yellow-400">Replans:</strong> ${replans}</p>`;
                }
                statsContainer.innerHTML = html;
            }

            function renderGrid() {
                gridContainer.innerHTML = '';
                gridContainer.style.gridTemplateColumns = `repeat(${state.grid[0].length}, 1fr)`;
                gridContainer.style.gridTemplateRows = `repeat(${state.grid.length}, 1fr)`;
                gridContainer.style.display = 'grid';
                gridContainer.style.gap = '1px';

                for (let y = 0; y < state.grid.length; y++) {
                    for (let x = 0; x < state.grid[y].length; x++) {
                        const cell = document.createElement('div');
                        cell.id = `cell-${y}-${x}`;
                        cell.className = 'grid-cell';
                        updateCell(y, x);
                        gridContainer.appendChild(cell);
                    }
                }
            }

            function updateCell(y, x, ...extraClasses) {
                const cell = document.getElementById(`cell-${y}-${x}`);
                if (!cell) return;
                
                const type = state.grid[y][x];
                let baseStyle = TILE_STYLES[type];
                
                if (!baseStyle) { // Not a special tile like wall, start, end
                   baseStyle = state.terrain ? TERRAIN_STYLES[state.terrain[y][x]] : 'bg-slate-100';
                }

                cell.className = `grid-cell ${TILE_STYLES.BASE} ${baseStyle} ${extraClasses.join(' ')}`;
            }

            function resetSimulation(mapKey) {
                if (state.currentAnimation) {
                    clearInterval(state.currentAnimation);
                    state.currentAnimation = null;
                }
                
                const map = MAPS[mapKey];
                // Deep copy grid to avoid mutation
                state.grid = map.grid.map(row => [...row]);
                state.terrain = map.terrain ? map.terrain.map(row => [...row]) : null;
                state.dynamicObstacles = (map.dynamicObstacles || []).map(obs => ({...obs, step: 0 }));

                renderGrid();
                
                statsContainer.innerHTML = `<p class="text-slate-600">Run a simulation to see results.</p>`;
                logContainer.innerHTML = '';
                addLog('System ready. Select an algorithm and start delivery.');
                setControlsEnabled(true);
            }

            function setControlsEnabled(enabled) {
                state.isRunning = !enabled;
                startBtn.disabled = !enabled;
                mapSelect.disabled = !enabled;
                algoSelect.disabled = !enabled;
                startBtn.textContent = enabled ? 'Start Delivery' : 'Running...';
            }
            
            function animate(actions) {
                return new Promise(resolve => {
                    if (actions.length === 0) {
                        resolve();
                        return;
                    }
                    let i = 0;
                    state.currentAnimation = setInterval(() => {
                        if (i >= actions.length) {
                            clearInterval(state.currentAnimation);
                            state.currentAnimation = null;
                            resolve();
                            return;
                        }
                        const { y, x, style, speed } = actions[i];
                        updateCell(y, x, style);
                        i++;
                    }, actions[0].speed); // Use speed of first action
                });
            }

            async function handleStart() {
                setControlsEnabled(false);
                const mapKey = mapSelect.value;
                const algo = algoSelect.value;
                const { start, end } = findStartEnd(state.grid);

                if (!start || !end) {
                    addLog("Error: Start or End point not found on the selected map!");
                    statsContainer.innerHTML = `<p class="text-red-400">Execution failed.</p>`;
                    setControlsEnabled(true);
                    return;
                }

                // Clear previous run visuals
                renderGrid();
                logContainer.innerHTML = '';
                statsContainer.innerHTML = `<p class="text-slate-600">Running simulation...</p>`;

                addLog(`Starting ${algo} on '${MAPS[mapKey].name}'.`);

                if (algo === ALGORITHMS.A_STAR_REPLAN) {
                    // --- REPLANNING SIMULATION ---
                    addLog("1. Calculating initial route...");
                    const initialResult = solve(ALGORITHMS.A_STAR, state.grid, start, end, state.terrain);
                    if (initialResult.path.length === 0) {
                        addLog("No initial path found! Halting.");
                        setControlsEnabled(true);
                        return;
                    }

                    await animate(initialResult.visitedOrder.map(n => ({ y: n.y, x: n.x, style: TILE_STYLES.VISITED, speed: ANIMATION_SPEEDS.VISITED })));
                    
                    // Introduce an obstacle halfway through the path
                    const blockIndex = Math.floor(initialResult.path.length / 1.5);
                    const blockPos = initialResult.path[blockIndex];
                    state.grid[blockPos.y][blockPos.x] = TILE_TYPE.WALL;
                    updateCell(blockPos.y, blockPos.x);
                    addLog(`2. [EVENT] Obstacle appeared at (${blockPos.y}, ${blockPos.x})!`);
                    
                    const pathBeforeBlock = initialResult.path.slice(0, blockIndex);
                    await animate(pathBeforeBlock.map(n => ({ y: n.y, x: n.x, style: TILE_STYLES.PATH, speed: ANIMATION_SPEEDS.AGENT })));

                    const agentCurrentPos = pathBeforeBlock[pathBeforeBlock.length - 1];
                    updateCell(agentCurrentPos.y, agentCurrentPos.x, TILE_STYLES.AGENT);
                    
                    addLog(`3. Agent stopped. Replanning from (${agentCurrentPos.y}, ${agentCurrentPos.x})...`);
                    const replanResult = solve(ALGORITHMS.A_STAR, state.grid, agentCurrentPos, end, state.terrain);
                    
                    if (replanResult.path.length === 0) {
                        addLog("Failed to find a new path! Agent is stuck.");
                        setControlsEnabled(true);
                        return;
                    }
                    
                    await animate(replanResult.visitedOrder.map(n => ({ y: n.y, x: n.x, style: TILE_STYLES.VISITED, speed: ANIMATION_SPEEDS.VISITED })));
                    
                    const finalFullPath = [...pathBeforeBlock, ...replanResult.path.slice(1)];
                    await animate(finalFullPath.map(n => ({ y: n.y, x: n.x, style: TILE_STYLES.PATH, speed: ANIMATION_SPEEDS.AGENT })));
                    
                    updateStats({
                        cost: 'N/A (Replanned)',
                        nodes: initialResult.visitedOrder.length + replanResult.visitedOrder.length,
                        time: (parseFloat(initialResult.time) + parseFloat(replanResult.time)).toFixed(2),
                        replans: 1,
                    });

                } else {
                    // --- STANDARD ALGORITHM EXECUTION ---
                    const { path, visitedOrder, totalCost, time } = solve(algo, state.grid, start, end, state.terrain);
                    
                    await animate(visitedOrder.map(n => ({ y: n.y, x: n.x, style: TILE_STYLES.VISITED, speed: ANIMATION_SPEEDS.VISITED })));
                    
                    if (path.length > 0) {
                        await animate(path.map(n => ({ y: n.y, x: n.x, style: TILE_STYLES.PATH, speed: ANIMATION_SPEEDS.AGENT })));
                        updateStats({ cost: totalCost, nodes: visitedOrder.length, time });
                    } else {
                        addLog("No path could be found.");
                        statsContainer.innerHTML = `<p class="text-red-400">No path found!</p>`;
                    }
                }

                addLog("Delivery complete.");
                setControlsEnabled(true);
            }

            function init() {
                // Populate dropdowns
                Object.keys(MAPS).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = MAPS[key].name;
                    mapSelect.appendChild(option);
                });
                Object.values(ALGORITHMS).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    algoSelect.appendChild(option);
                });
                
                mapSelect.value = 'medium';
                algoSelect.value = ALGORITHMS.A_STAR;

                // Setup event listeners
                mapSelect.addEventListener('change', (e) => resetSimulation(e.target.value));
                startBtn.addEventListener('click', handleStart);
                resetBtn.addEventListener('click', () => resetSimulation(mapSelect.value));
                
                // Initial load
                resetSimulation('medium');
            }
            
            init();
        });
    </script>
</body>
</html>



